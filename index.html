<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoRA Text Classification Training Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.2em;
        }
        
        .intro-section {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            margin: 20px 0;
            border-left: 5px solid #3498db;
        }
        
        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .parameter-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #e74c3c;
            text-align: center;
        }
        
        .parameter-value {
            font-size: 2em;
            font-weight: bold;
            color: #e74c3c;
            margin: 10px 0;
        }
        
        .equation-box {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            text-align: center;
            margin: 20px 0;
        }
        
        .training-info {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .info-card {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            text-align: center;
            border-left: 5px solid #3498db;
        }
        
        .loss-display {
            font-size: 2em;
            font-weight: bold;
            color: #e74c3c;
            margin: 10px 0;
        }
        
        .step-display {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
            margin: 10px 0;
        }
        
        .text-classification-demo {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #27ae60;
        }
        
        .sentence-example {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border: 2px solid #bdc3c7;
        }
        
        .sentiment-positive { border-color: #27ae60; background-color: #e8f8f2; }
        .sentiment-negative { border-color: #e74c3c; background-color: #fdeaea; }
        
        .matrix-container {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
        }
        
        .matrix {
            border: 2px solid #34495e;
            border-radius: 8px;
            padding: 12px;
            background: #f8f9fa;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .matrix:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
        }
        
        .matrix-label {
            text-align: center;
            font-weight: bold;
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 0.9em;
        }
        
        .matrix-row {
            display: flex;
            gap: 4px;
            margin: 2px 0;
        }
        
        .matrix-cell {
            width: 45px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #bdc3c7;
            border-radius: 3px;
            background: white;
            font-size: 10px;
            transition: all 0.3s ease;
        }
        
        .original { background-color: #e8f4fd !important; border-color: #3498db; }
        .lora-a { background-color: #fef2e8 !important; border-color: #f39c12; }
        .lora-b { background-color: #e8f8f2 !important; border-color: #27ae60; }
        .adapted { background-color: #f8e8f8 !important; border-color: #9b59b6; }
        .prediction { background-color: #e8ffe8 !important; border-color: #2ecc71; }
        .target { background-color: #ffe8e8 !important; border-color: #e74c3c; }
        
        .operator {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
            align-self: center;
        }
        
        .controls {
            text-align: center;
            margin: 30px 0;
        }
        
        .btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(52, 152, 219, 0.3);
        }
        
        .btn.active {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }
        
        .training-progress {
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            transition: width 0.5s ease;
            border-radius: 10px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        
        .chart {
            width: 100%;
            height: 200px;
            border: 1px solid #bdc3c7;
            background: #f8f9fa;
            position: relative;
            overflow: hidden;
        }
        
        .explanation {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        
        .highlight {
            background: #f1c40f;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        .animation-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .speed-slider {
            width: 100px;
        }
        
        .formula-breakdown {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .formula-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìù LoRA for Text Classification</h1>
        <p class="subtitle">Low-Rank Adaptation Training Visualization</p>
        
        <div class="intro-section">
            <h2>üî¨ What is LoRA?</h2>
            <p><strong>LoRA (Low-Rank Adaptation)</strong> is a parameter-efficient fine-tuning technique for large language models. Instead of updating all model parameters during fine-tuning, LoRA learns a small set of additional parameters by decomposing weight updates into low-rank matrices.</p>
            
            <div class="formula-breakdown">
                <div class="formula-card">
                    <h3>Core Principle</h3>
                    <div class="equation-box">
                        W_adapted = W_frozen + (Œ±/r) √ó B √ó A
                    </div>
                    <p><strong>W_frozen:</strong> Original pre-trained weights (frozen)<br>
                    <strong>A, B:</strong> Low-rank adaptation matrices (trainable)<br>
                    <strong>Œ±:</strong> Scaling factor<br>
                    <strong>r:</strong> Rank (dimensionality bottleneck)</p>
                </div>
                
                <div class="formula-card">
                    <h3>Matrix Dimensions</h3>
                    <ul>
                        <li><strong>W_frozen:</strong> d √ó d (original size)</li>
                        <li><strong>A:</strong> r √ó d (down-projection)</li>
                        <li><strong>B:</strong> d √ó r (up-projection)</li>
                        <li><strong>Trainable params:</strong> 2 √ó r √ó d</li>
                        <li><strong>Reduction:</strong> When r ‚â™ d</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="intro-section">
            <h2>‚öôÔ∏è LoRA Hyperparameters in This Demo</h2>
            <div class="parameter-grid">
                <div class="parameter-card">
                    <h3>Rank (r)</h3>
                    <div class="parameter-value">2</div>
                    <p>The bottleneck dimension. Lower r = fewer parameters but less expressiveness. Higher r = more parameters but better adaptation capability.</p>
                </div>
                
                <div class="parameter-card">
                    <h3>Alpha (Œ±)</h3>
                    <div class="parameter-value">4</div>
                    <p>Scaling factor for the adaptation. Controls how much the LoRA adaptation affects the final output. Œ±/r = 2.0 in our demo.</p>
                </div>
                
                <div class="parameter-card">
                    <h3>Learning Rate</h3>
                    <div class="parameter-value">0.1</div>
                    <p>How fast the LoRA matrices A and B are updated during training. Higher values = faster but potentially unstable learning.</p>
                </div>
                
                <div class="parameter-card">
                    <h3>Matrix Size</h3>
                    <div class="parameter-value">4√ó4</div>
                    <p>Original weight matrix size. In real models, this could be 768√ó768, 1024√ó1024, or even larger for attention layers.</p>
                </div>
            </div>
        </div>

        <div class="text-classification-demo">
            <h3>üìö Text Classification Task</h3>
            <p>We're training a sentiment classifier to distinguish positive and negative movie reviews:</p>
            
            <div class="sentence-example sentiment-positive">
                <strong>Input:</strong> "This movie was absolutely fantastic and entertaining!"<br>
                <strong>Target:</strong> Positive [1, 0] ‚Üí <strong>Prediction after training:</strong> [0.98, 0.02]
            </div>
            
            <div class="sentence-example sentiment-negative">
                <strong>Input:</strong> "The plot was boring and the acting was terrible."<br>
                <strong>Target:</strong> Negative [0, 1] ‚Üí <strong>Prediction after training:</strong> [0.05, 0.95]
            </div>
            
            <p><strong>Goal:</strong> Learn to map text embeddings to sentiment classifications by adapting only the final classification layer using LoRA.</p>
        </div>
        
        <div class="training-info">
            <div class="info-card">
                <h3>Current Step</h3>
                <div class="step-display" id="current-step">0</div>
                <div class="training-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="info-card">
                <h3>Classification Loss</h3>
                <div class="loss-display" id="current-loss">--</div>
                <small>Cross-Entropy Loss</small>
            </div>
            <div class="info-card">
                <h3>Accuracy</h3>
                <div style="font-size: 2em; font-weight: bold; color: #27ae60; margin: 10px 0;" id="current-accuracy">--</div>
                <small>Prediction accuracy</small>
            </div>
        </div>
        
        <div class="animation-controls">
            <button class="btn" onclick="resetTraining()">üîÑ Reset</button>
            <button class="btn" onclick="stepTraining()">‚ñ∂Ô∏è Next Step</button>
            <button class="btn" onclick="toggleAutoPlay()" id="autoplay-btn">üé¨ Auto Play</button>
            <div class="speed-control">
                <label>Speed:</label>
                <input type="range" class="speed-slider" min="0.5" max="3" step="0.5" value="1" id="speed-slider">
                <span id="speed-display">1x</span>
            </div>
        </div>

        <div id="matrices-display">
            <!-- Matrices will be displayed here -->
        </div>

        <div class="chart-container">
            <h3>üìà Training Progress: Loss and Accuracy</h3>
            <canvas id="loss-chart" class="chart" width="800" height="200"></canvas>
        </div>

        <div class="explanation">
            <h3>üîç What's Happening?</h3>
            <div id="step-explanation">
                <p>Initialize training with random LoRA matrices A and B. The frozen pre-trained weights remain unchanged while only A and B learn to adapt the model for sentiment classification.</p>
            </div>
        </div>

        <div class="intro-section">
            <h2>üí° Why LoRA is Powerful</h2>
            <div class="parameter-grid">
                <div class="parameter-card" style="border-left-color: #27ae60;">
                    <h3>Parameter Efficiency</h3>
                    <p><strong>Full Fine-tuning:</strong> 4√ó4 = 16 params<br>
                    <strong>LoRA (r=2):</strong> 2√ó4 + 4√ó2 = 16 params<br>
                    <strong>Real model (r=8, d=768):</strong> 97% reduction!</p>
                </div>
                
                <div class="parameter-card" style="border-left-color: #3498db;">
                    <h3>Memory & Speed</h3>
                    <p>‚úÖ Faster training<br>
                    ‚úÖ Lower GPU memory<br>
                    ‚úÖ Multiple task adapters<br>
                    ‚úÖ Easy deployment</p>
                </div>
                
                <div class="parameter-card" style="border-left-color: #9b59b6;">
                    <h3>Modularity</h3>
                    <p>‚úÖ Keep original model frozen<br>
                    ‚úÖ Switch between tasks<br>
                    ‚úÖ Combine adapters<br>
                    ‚úÖ Share base model</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Training configuration
        const RANK = 2;
        const ALPHA = 4;
        const LEARNING_RATE = 0.1;
        const SCALING_FACTOR = ALPHA / RANK; // 2.0
        
        // Training state
        let currentStep = 0;
        let isAutoPlaying = false;
        let autoPlayInterval;
        
        // Text classification target (sentiment classification)
        // Target output: [positive_prob, negative_prob]
        const sentimentTarget = [0.9, 0.1]; // Positive sentiment
        
        // Sample text embedding (representing "This movie was fantastic!")
        const textEmbedding = [0.8, 0.3, 0.6, 0.4];
        
        // Initial frozen weights (pre-trained classifier layer)
        const frozenWeights = [
            [0.2, -0.1, 0.3, -0.2],
            [-0.1, 0.4, 0.1, 0.3],
            [0.3, -0.2, 0.5, -0.1],
            [0.1, 0.2, -0.3, 0.4]
        ];
        
        // Training history
        let lossHistory = [];
        let accuracyHistory = [];
        let matrixHistory = [];
        
        function sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }
        
        function softmax(arr) {
            const expValues = arr.map(x => Math.exp(x));
            const sum = expValues.reduce((a, b) => a + b, 0);
            return expValues.map(x => x / sum);
        }
        
        function crossEntropyLoss(predictions, targets) {
            let loss = 0;
            for (let i = 0; i < predictions.length; i++) {
                loss -= targets[i] * Math.log(Math.max(predictions[i], 1e-15));
            }
            return loss;
        }
        
        function calculateAccuracy(predictions, targets) {
            const predClass = predictions.indexOf(Math.max(...predictions));
            const targetClass = targets.indexOf(Math.max(...targets));
            return predClass === targetClass ? 1.0 : 0.0;
        }
        
        function initializeTraining() {
            currentStep = 0;
            lossHistory = [];
            accuracyHistory = [];
            matrixHistory = [];
            
            // Initialize LoRA matrices A and B
            const initialA = [
                [0.05, -0.02, 0.08, -0.05],
                [0.04, 0.1, -0.03, 0.06]
            ];
            
            const initialB = [
                [0.08, 0.02],
                [-0.05, 0.05],
                [0.1, -0.08],
                [0.02, 0.08]
            ];
            
            // Simulate 10 training steps
            for (let step = 0; step <= 10; step++) {
                const A = simulateGradientUpdate(initialA, step, 'A');
                const B = simulateGradientUpdate(initialB, step, 'B');
                
                // Compute LoRA adaptation: ŒîW = B √ó A
                const deltaW = multiplyMatrices(B, A);
                
                // Scale by Œ±/r
                const scaledDeltaW = scaleMatrix(deltaW, SCALING_FACTOR);
                
                // Adapted weights: W_adapted = W_frozen + (Œ±/r) √ó ŒîW
                const adaptedWeights = addMatrices(frozenWeights, scaledDeltaW);
                
                // Forward pass: text_embedding ‚Üí classifier ‚Üí sentiment_prediction
                const logits = multiplyMatrixVector(adaptedWeights, textEmbedding);
                const predictions = softmax(logits.slice(0, 2)); // Take first 2 outputs for binary classification
                
                // Calculate loss and accuracy
                const loss = crossEntropyLoss(predictions, sentimentTarget);
                const accuracy = calculateAccuracy(predictions, sentimentTarget);
                
                matrixHistory.push({
                    step: step,
                    A: A,
                    B: B,
                    deltaW: deltaW,
                    scaledDeltaW: scaledDeltaW,
                    adapted: adaptedWeights,
                    predictions: predictions,
                    loss: loss,
                    accuracy: accuracy
                });
                
                lossHistory.push(loss);
                accuracyHistory.push(accuracy);
            }
        }
        
        function simulateGradientUpdate(initialMatrix, step, matrixType) {
            // Simulate realistic gradient descent updates for text classification
            const convergenceRate = 0.4;
            const noiseScale = 0.02;
            
            return initialMatrix.map((row, i) => 
                row.map((val, j) => {
                    // Simulate gradients that improve classification
                    const targetGradient = matrixType === 'A' ? 
                        (sentimentTarget[0] - 0.5) * 0.1 * (i + 1) / (j + 1) :
                        (sentimentTarget[0] - 0.5) * 0.08 * (j + 1) / (i + 1);
                    
                    const noise = (Math.random() - 0.5) * noiseScale;
                    const update = targetGradient * LEARNING_RATE * Math.exp(-step * convergenceRate);
                    
                    return val + update + noise;
                })
            );
        }
        
        function multiplyMatrices(A, B) {
            const result = [];
            for (let i = 0; i < A.length; i++) {
                result[i] = [];
                for (let j = 0; j < B[0].length; j++) {
                    result[i][j] = 0;
                    for (let k = 0; k < B.length; k++) {
                        result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return result;
        }
        
        function addMatrices(A, B) {
            return A.map((row, i) => row.map((val, j) => val + B[i][j]));
        }
        
        function scaleMatrix(matrix, scale) {
            return matrix.map(row => row.map(val => val * scale));
        }
        
        function multiplyMatrixVector(matrix, vector) {
            return matrix.map(row => 
                row.reduce((sum, val, i) => sum + val * vector[i], 0)
            );
        }
        
        function createMatrix(data, label, className = '', size = 'normal') {
            const container = document.createElement('div');
            container.className = 'matrix ' + className;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'matrix-label';
            labelDiv.textContent = label;
            container.appendChild(labelDiv);
            
            data.forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'matrix-row';
                
                const values = Array.isArray(row) ? row : [row];
                values.forEach(cell => {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'matrix-cell ' + className;
                    if (size === 'small') {
                        cellDiv.style.width = '35px';
                        cellDiv.style.height = '20px';
                        cellDiv.style.fontSize = '9px';
                    }
                    cellDiv.textContent = typeof cell === 'number' ? cell.toFixed(3) : cell;
                    rowDiv.appendChild(cellDiv);
                });
                
                container.appendChild(rowDiv);
            });
            
            return container;
        }
        
        function displayStep(step) {
            const data = matrixHistory[step];
            const container = document.getElementById('matrices-display');
            container.innerHTML = '';
            
            // Update UI elements
            document.getElementById('current-step').textContent = step;
            document.getElementById('current-loss').textContent = data.loss.toFixed(4);
            document.getElementById('current-accuracy').textContent = (data.accuracy * 100).toFixed(1) + '%';
            document.getElementById('progress-fill').style.width = (step / 10) * 100 + '%';
            
            // Title
            const title = document.createElement('h3');
            title.textContent = `Step ${step}: LoRA Adaptation for Text Classification`;
            title.style.textAlign = 'center';
            title.style.margin = '20px 0';
            container.appendChild(title);
            
            // LoRA computation: B √ó A = ŒîW
            const loraContainer = document.createElement('div');
            loraContainer.className = 'matrix-container';
            loraContainer.style.marginBottom = '20px';
            
            loraContainer.appendChild(createMatrix(data.B, `B (${data.B.length}√ó${data.B[0].length})`, 'lora-b', 'small'));
            
            const mult1 = document.createElement('div');
            mult1.className = 'operator';
            mult1.textContent = '√ó';
            loraContainer.appendChild(mult1);
            
            loraContainer.appendChild(createMatrix(data.A, `A (${data.A.length}√ó${data.A[0].length})`, 'lora-a', 'small'));
            
            const eq1 = document.createElement('div');
            eq1.className = 'operator';
            eq1.textContent = '=';
            loraContainer.appendChild(eq1);
            
            loraContainer.appendChild(createMatrix(data.deltaW, 'ŒîW', 'adapted', 'small'));
            
            container.appendChild(loraContainer);
            
            // Scaling: (Œ±/r) √ó ŒîW
            const scalingContainer = document.createElement('div');
            scalingContainer.className = 'matrix-container';
            scalingContainer.style.marginBottom = '20px';
            
            const scalingLabel = document.createElement('div');
            scalingLabel.textContent = `Scaling: (Œ±/r) = ${ALPHA}/${RANK} = ${SCALING_FACTOR}`;
            scalingLabel.style.width = '100%';
            scalingLabel.style.textAlign = 'center';
            scalingLabel.style.fontWeight = 'bold';
            scalingLabel.style.marginBottom = '10px';
            container.appendChild(scalingLabel);
            
            scalingContainer.appendChild(createMatrix([[SCALING_FACTOR]], '(Œ±/r)', 'original'));
            
            const mult2 = document.createElement('div');
            mult2.className = 'operator';
            mult2.textContent = '√ó';
            scalingContainer.appendChild(mult2);
            
            scalingContainer.appendChild(createMatrix(data.deltaW, 'ŒîW', 'adapted'));
            
            const eq2 = document.createElement('div');
            eq2.className = 'operator';
            eq2.textContent = '=';
            scalingContainer.appendChild(eq2);
            
            scalingContainer.appendChild(createMatrix(data.scaledDeltaW, 'Scaled ŒîW', 'adapted'));
            
            container.appendChild(scalingContainer);
            
            // Final adaptation: W_frozen + Scaled ŒîW
            const adaptContainer = document.createElement('div');
            adaptContainer.className = 'matrix-container';
            adaptContainer.style.marginBottom = '20px';
            
            adaptContainer.appendChild(createMatrix(frozenWeights, 'W_frozen', 'original'));
            
            const plus = document.createElement('div');
            plus.className = 'operator';
            plus.textContent = '+';
            adaptContainer.appendChild(plus);
            
            adaptContainer.appendChild(createMatrix(data.scaledDeltaW, 'Scaled ŒîW', 'adapted'));
            
            const eq3 = document.createElement('div');
            eq3.className = 'operator';
            eq3.textContent = '=';
            adaptContainer.appendChild(eq3);
            
            adaptContainer.appendChild(createMatrix(data.adapted, 'W_adapted', 'adapted'));
            
            container.appendChild(adaptContainer);
            
            // Forward pass: Text ‚Üí Prediction
            const forwardContainer = document.createElement('div');
            forwardContainer.className = 'matrix-container';
            forwardContainer.style.marginTop = '20px';
            
            const forwardTitle = document.createElement('h4');
            forwardTitle.textContent = 'Forward Pass: Text Classification';
            forwardTitle.style.textAlign = 'center';
            forwardTitle.style.width = '100%';
            container.appendChild(forwardTitle);
            
            forwardContainer.appendChild(createMatrix([textEmbedding], 'Text Embedding\n"Movie was fantastic!"', 'original'));
            
            const arrow1 = document.createElement('div');
            arrow1.className = 'operator';
            arrow1.textContent = '‚Üí';
            forwardContainer.appendChild(arrow1);
            
            forwardContainer.appendChild(createMatrix([data.predictions], `Prediction\n[Pos: ${data.predictions[0].toFixed(3)}, Neg: ${data.predictions[1].toFixed(3)}]`, 'prediction'));
            
            const vs = document.createElement('div');
            vs.className = 'operator';
            vs.textContent = 'vs';
            vs.style.fontSize = '1em';
            forwardContainer.appendChild(vs);
            
            forwardContainer.appendChild(createMatrix([sentimentTarget], 'Target\n[Pos: 0.9, Neg: 0.1]', 'target'));
            
            container.appendChild(forwardContainer);
            
            // Update explanation
            updateStepExplanation(step, data.loss, data.accuracy);
            
            // Update charts
            drawCharts();
        }
        
        function updateStepExplanation(step, loss, accuracy) {
            const explanationDiv = document.getElementById('step-explanation');
            let explanation = '';
            
            if (step === 0) {
                explanation = `<strong>Initialization:</strong> Starting with random LoRA matrices A and B. The model predicts randomly with high loss (${loss.toFixed(4)}) and low accuracy (${(accuracy*100).toFixed(1)}%).`;
            } else if (step <= 3) {
                explanation = `<strong>Early Learning (Step ${step}):</strong> LoRA matrices are being updated via gradient descent. The model is learning to classify sentiments. Loss: ${loss.toFixed(4)}, Accuracy: ${(accuracy*100).toFixed(1)}%.`;
            } else if (step <= 7) {
                explanation = `<strong>Convergence (Step ${step}):</strong> The adaptation is working well. Positive sentiment predictions are getting stronger. Loss: ${loss.toFixed(4)}, Accuracy: ${(accuracy*100).toFixed(1)}%.`;
            } else {
                explanation = `<strong>Optimized (Step ${step}):</strong> LoRA has successfully adapted the classifier. The model confidently predicts positive sentiment with low loss: ${loss.toFixed(4)}, Accuracy: ${(accuracy*100).toFixed(1)}%.`;
            }
            
            explanationDiv.innerHTML = `<p>${explanation}</p>`;
        }
        
        function drawCharts() {
            const canvas = document.getElementById('loss-chart');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            if (lossHistory.length === 0) return;
            
            // Draw grid
            ctx.strokeStyle = '#ecf0f1';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 10; i++) {
                const x = (i / 10) * (width - 60) + 40;
                ctx.beginPath();
                ctx.moveTo(x, 20);
                ctx.lineTo(x, height - 40);
                ctx.stroke();
            }
            
            for (let i = 0; i <= 5; i++) {
                const y = (i / 5) * (height - 60) + 20;
                ctx.beginPath();
                ctx.moveTo(40, y);
                ctx.lineTo(width - 20, y);
                ctx.stroke();
            }
            
            // Draw loss curve
            const maxLoss = Math.max(...lossHistory);
            const minLoss = Math.min(...lossHistory);
            const lossRange = maxLoss - minLoss || 1;
            
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i <= currentStep && i < lossHistory.length; i++) {
                const x = (i / 10) * (width - 60) + 40;
                const normalizedLoss = (lossHistory[i] - minLoss) / lossRange;
                const y = height - 40 - normalizedLoss * (height - 60);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Draw accuracy curve
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i <= currentStep && i < accuracyHistory.length; i++) {
                const x = (i / 10) * (width - 60) + 40;
                const y = height - 40 - accuracyHistory[i] * (height - 60);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Current point
            if (currentStep < lossHistory.length) {
                const x = (currentStep / 10) * (width - 60) + 40;
                
                // Loss point
                const normalizedLoss = (lossHistory[currentStep] - minLoss) / lossRange;
                const lossY = height - 40 - normalizedLoss * (height - 60);
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(x, lossY, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Accuracy point
                const accY = height - 40 - accuracyHistory[currentStep] * (height - 60);
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(x, accY, 6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Labels
            ctx.fillStyle = '#2c3e50';
            ctx.font = '12px Arial';
            ctx.fillText('Loss/Accuracy', 5, height / 2);
            ctx.fillText('Training Steps', width / 2 - 30, height - 5);
            ctx.fillText('0', 35, height - 25);
            ctx.fillText('10', width - 25, height - 25);
            
            // Legend
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(width - 150, 30, 15, 3);
            ctx.fillStyle = '#2c3e50';
            ctx.fillText('Loss', width - 130, 35);
            
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(width - 150, 50, 15, 3);
            ctx.fillStyle = '#2c3e50';
            ctx.fillText('Accuracy', width - 130, 55);
        }
        
        function stepTraining() {
            if (currentStep < 10) {
                currentStep++;
                displayStep(currentStep);
            }
        }
        
        function resetTraining() {
            currentStep = 0;
            stopAutoPlay();
            initializeTraining();
            displayStep(0);
        }
        
        function toggleAutoPlay() {
            if (isAutoPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }
        
        function startAutoPlay() {
            isAutoPlaying = true;
            document.getElementById('autoplay-btn').textContent = '‚è∏Ô∏è Pause';
            const speed = parseFloat(document.getElementById('speed-slider').value);
            
            autoPlayInterval = setInterval(() => {
                if (currentStep < 10) {
                    stepTraining();
                } else {
                    resetTraining();
                }
            }, 1500 / speed);
        }
        
        function stopAutoPlay() {
            isAutoPlaying = false;
            document.getElementById('autoplay-btn').textContent = 'üé¨ Auto Play';
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
            }
        }
        
        document.getElementById('speed-slider').addEventListener('input', function() {
            const speed = this.value;
            document.getElementById('speed-display').textContent = speed + 'x';
            
            if (isAutoPlaying) {
                stopAutoPlay();
                startAutoPlay();
            }
        });
        
        // Initialize
        initializeTraining();
        displayStep(0);
    </script>
</body>
</html>